1) JavaScript execution context

    consider the following program 

    var a = 2;
    function sqaure(num){
        var ans = num * num;
        return ans;
    }
    var squre2 = sqaure(a);
    var squre4 = sqaure(4);

    executionContext has two parts that is
    memory and code 
    in first phase of the execution a, sqaure2 and squre4 memory allocated with undefined values
    and squre memory allocated with function code 

    in second phase of the execution
    for functtion squre execution of square2 create separate execution context and ans with undefined values
    same for squre4  

    this is called as callstack/machine stack etc .
    first phase of the execution is global phase and other execution context is pushed and poped it according to need

    check in broswer source tab;

2) Hoisting

    It will give the access to the variables before initialization

    if function is defined as variable then memory will be allocated to it but it will give undefined error
    first executionContext 

3) How function works 
    refer code in index.js 
    for x, it will create a seperate memory allocation for each next phase of the execution/call stack
    
4) shortest JS program
    blank index.js, still it will create global execution context
    check on console 
        window
        this
        this === window 

    JS engine(eg. chromian) will create windows object in broswer;
    JS is loosely coupled variable system
    var a = undefined // wrong practice, avoid it
    
5) Scope chain and lexical environment

    code in index.js will print 15 because scope chain and lexical environment 
    lexical environment is current executionContext + parent executionContext. it has refernace of it's parent lexical environment 
    global executionContext -> parent refernace is null;